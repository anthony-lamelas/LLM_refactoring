#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define IF_ELSE } else if (
#define IF p (
#define ELSE_IF IF_ELSE
#define PRINTF sprintf
#define ARROW ->
#define INCREMENT f++
#define CALL(s) (s)
#define STRUCT_PTR struct Data*
#define DECL_STRUCT struct Data { union { char *f; double n; }; char *g, h, l, m; STRUCT_PTR e, x, b, q, (*r) CALL(); int u; }
typedef STRUCT_PTR e;
DECL_STRUCT;
e q, v;
int y, (*w) CALL() = strlen, (*A) CALL() = strcmp;
char *B, *f, C, r = 0, g[99], *(*D) CALL() = strdup;

e createNode(int m) {
    e node = calloc(1, sizeof(STRUCT_PTR));
    node ARROW b = v;
    node ARROW m = m;
    return v = node;
}

e findNode(e node) {
    while (node) {
        IF !A(g, node ARROW g)) {
            return node;
        }
        node = node ARROW b;
    }
    return NULL;
}

e addNode(e *q) {
    e node = createNode(4);
    node ARROW g = D(g);
    node ARROW b = *q;
    node ARROW x = createNode(0);
    return *q = node;
}

void skipWhitespaceAndComments() {
    int x;
    while ((x = *f == '/' && f[1] == '/') || isspace(*f)) {
        IF x) {
            while (*f && *f != '\n') INCREMENT;
        } ELSE {
            INCREMENT;
        }
    }
}

void skipNonWhitespace() {
    skipWhitespaceAndComments();
    IF *f) INCREMENT;
}

int findCharPosition(char *str, char ch) {
    char *pos = strchr(str, ch);
    return pos ? pos - str : -1;
}

int isEndOfStatement() {
    return findCharPosition(";)]") != -1;
}

int matchString(char *str) {
    int len = w(str);
    IF !strncmp(str, f, len) && !isalnum(f[len])) {
        f += len;
        return 1;
    }
    return 0;
}

void parseBlock() {
    int depth = 1;
    while (*f && depth) {
        C = *INCREMENT;
        depth += C == '{' ? 1 : (C == '}') ? -1 : 0;
    }
}

double evaluateNode(e node) {
    char *P;
    return node ARROW m & 1 ? node ARROW n :
           node ARROW m & 2 ? strtod(node ARROW f, &P) : 0;
}

e duplicateNode(e node) {
    e newNode = createNode(2);
    char *f = "[object]";
    char m = node ARROW m;
    IF m & 1) {
        PRINTF(g, "%g", node ARROW n);
        f = g;
    }
    IF m & 2) f = node ARROW f;
    newNode ARROW f = D(f);
    return newNode;
}

e parseExpression(e *q);

int isIdentifierChar() {
    return *f == '_' || isalnum(*f);
}

void parseIdentifier() {
    char *d = g;
    while (isIdentifierChar()) *d++ = *INCREMENT;
    *d = 0;
}

e parsePrimary(int h);

e parseCompound(e *q);

void parse() {
    char *B = g;
    int P;
    e l = parsePrimary(0);
    skipNonWhitespace();
    IF !(int)(l ARROW n) r = 4;
    P = r;
    e y = parseCompound(q);
    IF *f == ';') INCREMENT;
    IF !P) x = y;
    skipWhitespaceAndComments();
    IF u) {
        IF !r && !P) {
            x = y;
            f = B;
            parse();
        }
        ELSE {
        }
        ELSE_IF r = (!P && !d) * 4;
        P = r;
        y = parseCompound(q);
        IF !P) x = y;
    }
    r = u ? d & ~2 : d | (r & 3);
    ELSE_IF while) u = 1;
    parse();
    ELSE_IF return) y = parsePrimary(0);
    IF !r) {
        x = y;
        r |= 1;
    }
    ELSE_IF break) IF !r) r |= 2;
    ELSE_IF *f) {
        y = parsePrimary(0);
        IF !r) x = y;
        skipNonWhitespace();
    }
}

e parsePrimary(int h) {
    int i = 0, j, n, P, V;
    double X, Y;
    char *d, b;
    e l, y, x = createNode(0), u;
    skipWhitespaceAndComments();
    IF isEndOfStatement()) {
        return x;
    }
    i = findCharPosition("-+!~");
    IF i > -1) {
        INCREMENT;
    }
    C = *f;
    IF C == '(') {
        INCREMENT;
        x = parsePrimary(0);
        skipNonWhitespace();
    }
    ELSE_IF C == '[' || C == '{') {
        x ARROW m = 4;
        INCREMENT;
        skipNonWhitespace();
    }
    ELSE_IF C == '"' || C == '\'') {
        d = g;
        INCREMENT;
        x ARROW m = 2;
        while (*f != C) {
            char P = *INCREMENT;
            IF P == '\\') {
                P = *INCREMENT;
                P = P == 'n' ? '\n' : P == 'x' ? strtol(f, &f, 16) : P;
            }
            *d++ = P;
        }
        *d = 0;
        INCREMENT;
        x ARROW f = D(g);
    }
    ELSE_IF isdigit(*f)) {
        x ARROW m = 1;
        x ARROW n = strtod(f, &f);
    }
    ELSE_IF isIdentifierChar()) {
        int W = 0;
        g : parseIdentifier();
        IF matchString("function")) {
            skipNonWhitespace();
            skipNonWhitespace();
            skipNonWhitespace();
            d = f - 1;
            x = createNode(2);
            parseBlock();
            x ARROW f = strndup(d, f - d);
        }
        ELSE {
            IF matchString("var")) {
                INCREMENT;
                W = 1;
                goto g;
            }
            u = findNode(q);
            IF W || !u) u = addNode(&q);
            x = u ARROW x;
            x ARROW e = u;
        }
    }
    IF i > -1) {
        X = evaluateNode(x);
        n = X;
        IF j == 0) {
            ELSE_IF X = -X ELSE_IF ELSE_IF X = !n ELSE_IF X = ~n;
        }
        x = createNode(1);
        x ARROW n = X;
    }
    while (*f) {
        skipWhitespaceAndComments();
        IF isEndOfStatement()) break;
        i = findCharPosition(",=!&|><-+*/%[(.");
        IF i > -1) {
            b = *f;
            IF i < h) {
                break;
            }
            int W = 0, k = 0, h = 0;
            INCREMENT;
            IF *f == '=') {
                W = 2;
                INCREMENT;
            }
            ELSE_IF *f == b) {
                h = 1;
                INCREMENT;
            }
            y = 0;
            l = createNode(1);
            X = evaluateNode(x);
            double *Z = &l ARROW n;
            char m = x ARROW m;
            n = X;
            IF i < 13) {
                y = parsePrimary(i == 12 ? 0 : i);
                Y = evaluateNode(y);
                P = Y;
            }
            IF j == 0) {
                ELSE_IF l = y ELSE_IF W) {
                    P = x != y;
                    ELSE_IF m & 1) goto O;
                    ELSE goto Q;
                }
                ELSE_IF (m | y ARROW m) == 2) {
                    Q : P = A(duplicateNode(x) ARROW f, duplicateNode(y) ARROW f);
                }
                ELSE {
                    O : P = X - Y;
                }
                i = k;
                IF j == 0) {
                    ELSE_IF P = P == 0 ELSE_IF P >= 0 ELSE_IF P <= 0 ELSE_IF P > 0 ELSE_IF P < 0 ELSE_IF P != 0;
                }
                *Z = P;
                W = 0;
            }
            ELSE {
                W = 1;
                IF y ARROW m & 4) {
                    l = y;
                }
                ELSE {
                    l = createNode(y ARROW m);
                    l ARROW r = y ARROW r;
                    IF y ARROW m & 2) l ARROW f = D(y ARROW f);
                    ELSE l ARROW n = y ARROW n;
                }
            }
            ELSE_IF k = 5;
            goto V;
            ELSE_IF *Z = h ? n && P : n & P ELSE_IF *Z = h ? n || P : n | P ELSE_IF h) {
                *Z = n >> P;
            }
            ELSE {
                k = 3 - W;
                goto V;
            }
            ELSE_IF h) {
                *Z = n << P;
            }
            ELSE {
                k = 4 - W;
                goto V;
            }
            ELSE_IF *Z = X - Y ELSE_IF (m | y ARROW m) & 2) {
                e u = duplicateNode(x);
                y = duplicateNode(y);
                d = malloc(w(u ARROW f) + w(y ARROW f) + 1);
                PRINTF(d, "%s%s", u ARROW f, y ARROW f);
                l ARROW m = 2;
                l ARROW f = d;
            }
            ELSE {
                *Z = X + Y;
            }
            ELSE_IF *Z = X * Y ELSE_IF *Z = X / Y ELSE_IF *Z = n % P ELSE_IF skipNonWhitespace();
            IF m & 2) {
                PRINTF(g, "%c", P < w(x ARROW f) ? x ARROW f[P] : 0);
                l ARROW m = 2;
                l ARROW f = D(g);
            }
            ELSE {
                PRINTF(g, "%s", duplicateNode(y) ARROW f);
                goto q;
            }
            ELSE_IF PRINTF(g, "arguments");
            e B = q, u = addNode(&q) ARROW x;
            i = 0;
            while (*f) {
                skipWhitespaceAndComments();
                y = parsePrimary(1);
                IF !r) {
                    PRINTF(g, "%d", i++);
                    addNode(&u ARROW q) ARROW x = y;
                    u ARROW u++;
                }
                IF *f == ')') break;
                INCREMENT;
            }
            INCREMENT;
            i = r;
            IF x ARROW r) {
                IF !r) l = x ARROW r(u ARROW q);
            }
            ELSE {
                d = f;
                f = x ARROW f;
                l = parseExpression(0);
                f = d;
            }
            IF !i) {
                r = i & ~1;
            }
            q = B;
            ELSE_IF skipWhitespaceAndComments();
            parseIdentifier();
            IF matchString("length")) {
                *Z = x ARROW m & 2 ? w(x ARROW f) : x ARROW u;
            }
            ELSE {
                q : y = findNode(x ARROW q);
                IF !y) {
                    y = addNode(&x ARROW q);
                    x ARROW u++;
                }
                l = y ARROW x;
                IF !l ARROW e) l ARROW e = y;
            }
        }
        IF W) {
            IF !r) {
                l = x ARROW e ARROW x = l;
            }
            ELSE continue;
        }
        x = l;
    }
    ELSE INCREMENT;
    return x;
}

e parseExpression(e *q) {
    e x = createNode(0), y, l, d = q, u = v;
    while (*f) {
        skipWhitespaceAndComments();
        IF *f == '{') {
            INCREMENT;
            IF !r) x = parseExpression(1);
            ELSE parseBlock();
        }
        ELSE {
            int u = 0, d;
            IF *f == '}') {
                INCREMENT;
                break;
                ELSE_IF if) char *B;
                int P;
                u : d = r;
                j : B = f;
                skipNonWhitespace();
                l = parsePrimary(0);
                skipNonWhitespace();
                IF !(int)(l ARROW n) r = 4;
                P = r;
                y = parseExpression(0);
                IF *f == ';') INCREMENT;
                IF !P) {
                    x = y;
                }
                skipWhitespaceAndComments();
                IF u) {
                    IF !r && !P) {
                        x = y;
                        f = B;
                        goto j;
                    }
                    ELSE {
                    }
                    ELSE_IF else) r = (!P && !d) * 4;
                    P = r;
                    y = parseExpression(0);
                    IF !P) x = y;
                }
                r = u ? d & ~2 : d | (r & 3);
                ELSE_IF while) u = 1;
                goto u;
                ELSE_IF return) y = parsePrimary(0);
                IF !r) {
                    x = y;
                    r |= 1;
                }
                ELSE_IF break) IF !r) r |= 2;
            }
            ELSE_IF *f) {
                y = parsePrimary(0);
                IF !r) x = y;
                skipNonWhitespace();
            }
        }
        IF !h) break;
    }
    x ARROW l = 1;
    x ARROW l = 0;
    q = d;
    return x;
}

e printNode(e node) {
    printf("%s", duplicateNode(node) ARROW f);
    return createNode(0);
}

int main() {
    PRINTF(g, "print");
    e x = addNode(&q);
    x ARROW m = 2;
    x ARROW r = printNode;
    char u[1 << 16];
    B = f = u;
    while ((C = getchar()) > 0) *INCREMENT = C;
    *f = 0;
    f = B;
    parseExpression(1);
}