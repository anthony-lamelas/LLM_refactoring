```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Macro definitions for code simplification
#define CHECK_FUNCTION_END(x) } else if (parseFunction(#x)) {
#define CHECK_OPERATOR_END ; } else if (i == j++) {
#define FORMAT_STRING sprintf
#define ACCESS_MEMBER ->
#define IF_CONDITION if (
#define INCREMENT_COUNTER f++
#define EMPTY_PARAMETER ( )
#define ACCESS_FIELD x ACCESS_MEMBER

// Typedefs and struct definitions
typedef struct Node* NodePointer;
struct Node {
    union {
        char *f;
        double n;
    };
    char *g, h, l, m;
    NodePointer e, x, b, q, (*r) EMPTY_PARAMETER;
    int u;
};

// Global variables
NodePointer q, v;
int y, (*getStrLen) EMPTY_PARAMETER = strlen, (*compareStr) EMPTY_PARAMETER = strcmp;
char *B, *f, C, r = 0, g[99], *(*duplicateStr) EMPTY_PARAMETER = strdup;

// Function declarations
NodePointer createNode(int m);
NodePointer findNode(NodePointer q);
NodePointer allocateNode(NodePointer *q);
void skipWhitespace(EMPTY_PARAMETER);
void skipCommentOrWhitespace(EMPTY_PARAMETER);
int findCharIndex(char *str);
int checkDelimiter(EMPTY_PARAMETER);
int matchFunction(char *x);
int parseFunction(char *x);
int isValidIdentifierChar(EMPTY_PARAMETER);
void parseIdentifier(EMPTY_PARAMETER);
NodePointer parseExpression(int h);
double evaluateNode(NodePointer x);
NodePointer copyNode(NodePointer x);
void skipStatement(EMPTY_PARAMETER);
NodePointer processNode(int h);
void traverseAndFree(NodePointer x, NodePointer l, int b);
void freeNodes(NodePointer l);
NodePointer execute(int h);
NodePointer printNode(NodePointer x);
int main(EMPTY_PARAMETER);

// Function implementations
NodePointer createNode(int m) {
    NodePointer newNode = calloc(1, sizeof(struct Node));
    newNode->b = v;
    newNode->m = m;
    return v = newNode;
}

NodePointer findNode(NodePointer q) {
    while (q) {
        if (!compareStr(g, q ACCESS_MEMBER g)) {
            return q;
        }
        q = q ACCESS_MEMBER b;
    }
    return 0;
}

NodePointer allocateNode(NodePointer *q) {
    NodePointer newNode = createNode(4);
    newNode->g = duplicateStr(g);
    newNode->b = *q;
    newNode->x = createNode(0);
    return *q = newNode;
}

void skipWhitespace(EMPTY_PARAMETER) {
    int x;
    while ((x = *f == '/' && f[1] == '/') || isspace(*f)) {
        if (x) {
            while (*f && *f != 10) INCREMENT_COUNTER;
        } else {
            INCREMENT_COUNTER;
        }
    }
}

void skipCommentOrWhitespace(EMPTY_PARAMETER) {
    skipWhitespace EMPTY_PARAMETER;
    if (*f) INCREMENT_COUNTER;
}

int findCharIndex(char *str) {
    char *d = strchr(str, *f);
    return d ? d - str : -1;
}

int checkDelimiter(EMPTY_PARAMETER) {
    return findCharIndex(";)]") != -1;
}

int matchFunction(char *x) {
    return !compareStr(x, g);
}

int parseFunction(char *x) {
    int u = getStrLen(x);
    if (!strncmp(x, f, u) && !isalnum(f[u])) {
        f += u;
        return 1;
    }
    return 0;
}

int isValidIdentifierChar(EMPTY_PARAMETER) {
    return *f == '_' || isalnum(*f);
}

void parseIdentifier(EMPTY_PARAMETER) {
    char *d = g;
    while (isValidIdentifierChar EMPTY_PARAMETER) *d++ = *f++;
    *d = 0;
}

NodePointer parseExpression(int h) {
    int i = 0, j, n, P, V;
    double X, Y;
    char *d, b;
    NodePointer l, y, x = createNode(0), u;
    
    skipWhitespace EMPTY_PARAMETER;
    
    if (checkDelimiter EMPTY_PARAMETER) {
        return x;
    }
    
    i = findCharIndex("-+!~");
    if (i > -1) {
        INCREMENT_COUNTER;
    }
    
    C = *f;
    
    if (C == '(') {
        INCREMENT_COUNTER;
        x = parseExpression(0);
        skipCommentOrWhitespace EMPTY_PARAMETER;
    } else if (C == '[' || C == '{') {
        ACCESS_FIELD m = 4;
        INCREMENT_COUNTER;
        skipCommentOrWhitespace EMPTY_PARAMETER;
    } else if (C == '"' || C == '\'') {
        d = g;
        INCREMENT_COUNTER;
        ACCESS_FIELD m = 2;
        while (*f != C) {
            char P = *f++;
            if (P == '\\') {
                P = *f++;
                P = P == 'n' ? 10 : P == 'x' ? strtol(f, &f, 16) : P;
            }
            *d++ = P;
        }
        *d = 0;
        INCREMENT_COUNTER;
        ACCESS_FIELD f = duplicateStr(g);
    } else if (isdigit(*f)) {
        ACCESS_FIELD m = 1;
        ACCESS_FIELD n = strtod(f, &f);
    } else if (isValidIdentifierChar EMPTY_PARAMETER) {
        int W = 0;
        g: parseIdentifier EMPTY_PARAMETER;
        
        if (matchFunction("function")) {
            skipCommentOrWhitespace EMPTY_PARAMETER;
            skipCommentOrWhitespace EMPTY_PARAMETER;
            skipCommentOrWhitespace EMPTY_PARAMETER;
            d = f - 1;
            x = createNode(2);
            skipStatement EMPTY_PARAMETER;
            ACCESS_FIELD f = strndup(d, f - d);
        } else {
            if (matchFunction("var")) {
                INCREMENT_COUNTER;
                W = 1;
                goto g;
            }
            u = findNode(q);
            if (W || !u) u = allocateNode(&q);
            x = u ACCESS_MEMBER x;
            ACCESS_FIELD e = u;
        }
    }
    
    if (i > -1) {
        X = evaluateNode(x);
        n = X;
        if (j == 0) {
            CHECK_OPERATOR_END
                X = -X
            CHECK_OPERATOR_END
                X = !n
            CHECK_OPERATOR_END
                X = ~n;
        }
        x = createNode(1);
        ACCESS_FIELD n = X;
    }
    
    while (*f) {
        skipWhitespace EMPTY_PARAMETER;
        if (checkDelimiter EMPTY_PARAMETER) break;
        
        i = findCharIndex(",=!&|><-+*/%[(.");
        if (i > -1) {
            b = *f;
            if (i < h) break;
            
            int W = 0, k = 0, h = 0;
            INCREMENT_COUNTER;
            
            if (*f == '=') {
                W = 2;
                INCREMENT_COUNTER;
            } else if (*f == b) {
                h = 1;
                INCREMENT_COUNTER;
            }
            
            y = 0;
            l = createNode(1);
            X = evaluateNode(x);
            double *Z = &l ACCESS_MEMBER n;
            char m = ACCESS_FIELD m;
            n = X;
            
            if (i < 13) {
                y = parseExpression(i == 12 ? 0 : i);
                Y = evaluateNode(y);
                P = Y;
            }
            
            if (j == 0) {
                CHECK_OPERATOR_END
                    l = y
                CHECK_OPERATOR_END
                if (W) {
                    V: if (m == y ACCESS_MEMBER m) {
                        if (m & 4) V = x != y;
                        else if (m & 1) goto O;
                        else goto Q;
                    } else if ((m | y ACCESS_MEMBER m) == 2) {
                        Q: V = compareStr(copyNode(x) ACCESS_MEMBER f, copyNode(y) ACCESS_MEMBER f);
                    } else {
                        O: V = X - Y;
                    }
                    i = k;
                    if (j == 0) {
                        CHECK_OPERATOR_END
                            V = V == 0
                        CHECK_OPERATOR_END
                            V = V >= 0
                        CHECK_OPERATOR_END
                            V = V <= 0
                        CHECK_OPERATOR_END
                            V = V > 0
                        CHECK_OPERATOR_END
                            V = V < 0
                        CHECK_OPERATOR_END
                            V = V != 0;
                    }
                    *Z = V;
                    W = 0;
                } else {
                    W = 1;
                    if (y ACCESS_MEMBER m & 4) {
                        l = y;
                    } else {
                        l = createNode(y ACCESS_MEMBER m);
                        l ACCESS_MEMBER r = y ACCESS_MEMBER r;
                        if (y ACCESS_MEMBER m & 2) l ACCESS_MEMBER f = duplicateStr(y ACCESS_MEMBER f);
                        else l ACCESS_MEMBER n = y ACCESS_MEMBER n;
                    }
                }
                CHECK_OPERATOR_END
                    k = 5;
                    goto V
                CHECK_OPERATOR_END
                    *Z = h ? n && P : n & P
                CHECK_OPERATOR_END
                    *Z = h ? n || P : n | P
                CHECK_OPERATOR_END
                if (h) {
                    *Z = n >> P;
                } else {
                    k = 3 - W;
                    goto V;
                }
                CHECK_OPERATOR_END
                if (h) {
                    *Z = n << P;
                } else {
                    k = 4 - W;
                    goto V;
                }
                CHECK_OPERATOR_END
                    *Z = X - Y
                CHECK_OPERATOR_END
                if ((m | y ACCESS_MEMBER m) & 2) {
                    NodePointer u = copyNode(x);
                    y = copyNode(y);
                    d = malloc(getStrLen(u ACCESS_MEMBER f) + getStrLen(y ACCESS_MEMBER f) + 1);
                    FORMAT_STRING(d, "%s%s", u ACCESS_MEMBER f, y ACCESS_MEMBER f);
                    l ACCESS_MEMBER m = 2;
                    l ACCESS_MEMBER f = d;
                } else {
                    *Z = X + Y;
                }
                CHECK_OPERATOR_END
                    *Z = X * Y
                CHECK_OPERATOR_END
                    *Z = X / Y
                CHECK_OPERATOR_END
                    *Z = n % P
                CHECK_OPERATOR_END
                skipCommentOrWhitespace EMPTY_PARAMETER;
                
                if (m & 2) {
                    FORMAT_STRING(g, "%c", P < getStrLen(ACCESS_FIELD f) ? ACCESS_FIELD f[P] : 0);
                    l ACCESS_MEMBER m = 2;
                    l ACCESS_MEMBER f = duplicateStr(g);
                } else {
                    FORMAT_STRING(g, "%s", copyNode(y) ACCESS_MEMBER f);
                    goto q;
                }
                CHECK_OPERATOR_END
                    FORMAT_STRING(g, "arguments");
                    NodePointer B = q, u = allocateNode(&q) ACCESS_MEMBER x;
                    i = 0;
                    while (*f) {
                        skipWhitespace EMPTY_PARAMETER;
                        y = parseExpression(1);
                        if (!r) {
                            FORMAT_STRING(g, "%d", i++);
                            allocateNode(&u ACCESS_MEMBER q) ACCESS_MEMBER x = y;
                            u ACCESS_MEMBER u++;
                        }
                        if (*f == ')') break;
                        INCREMENT_COUNTER;
                    }
                    INCREMENT_COUNTER;
                    i = r;
                    if (ACCESS_FIELD r) {
                        if (!r) l = ACCESS_FIELD r(u ACCESS_MEMBER q);
                    } else {
                        d = f;
                        f = ACCESS_FIELD f;
                        l = execute(0);
                        f = d;
                    }
                    if (!i) {
                        r = i & ~1;
                    }
                    q = B;
                    CHECK_OPERATOR_END
                        skipWhitespace EMPTY_PARAMETER;
                        parseIdentifier EMPTY_PARAMETER;
                        if (matchFunction("length")) {
                            *Z = m & 2 ? getStrLen(ACCESS_FIELD f) : ACCESS_FIELD u;
                        } else {
                            q: y = findNode(ACCESS_FIELD q);
                            if (!y) {
                                y = allocateNode(&ACCESS_FIELD q);
                                ACCESS_FIELD u++;
                            }
                            l = y ACCESS_MEMBER x;
                            if (!l ACCESS_MEMBER e) l ACCESS_MEMBER e = y;
                        }
                    }
                    if (W) {
                        if (!r) {
                            l = ACCESS_FIELD e ACCESS_MEMBER x = l;
                        } else {
                            continue;
                        }
                    }
                    x = l;
                } else {
                    INCREMENT_COUNTER;
                }
            }
            return x;
        }
    }
    return 0;
}

double evaluateNode(NodePointer x) {
    char *P;
    return ACCESS_FIELD m & 1 ? ACCESS_FIELD n : ACCESS_FIELD m & 2 ? strtod(ACCESS_FIELD f, &P) : 0;
}

NodePointer copyNode(NodePointer x) {
    NodePointer newNode = createNode(2);
    char *f = "[object]", m = ACCESS_FIELD m;
    if (m & 1) {
        FORMAT_STRING(g, "%g", ACCESS_FIELD n);
        f = g;
    }
    if (m & 2) f = ACCESS_FIELD f;
    newNode ACCESS_MEMBER f = duplicateStr(f);
    return newNode;
}

void skipStatement(EMPTY_PARAMETER) {
    skipWhitespace EMPTY_PARAMETER;
    if (*f) INCREMENT_COUNTER;
}

NodePointer processNode(int h) {
    NodePointer x = createNode(0), y, l, d = q, u = v;
    
    while (*f) {
        skipWhitespace EMPTY_PARAMETER;
        if (*f == '{') {
            INCREMENT_COUNTER;
            if (!r) x = processNode(1);
            else skipStatement EMPTY_PARAMETER;
        } else {
            int u = 0, d;
            if (*f == '}') {
                INCREMENT_COUNTER;
                break;
                CHECK_FUNCTION_END
                    char *B;
                    int P;
                    u: d = r;
                    j: B = f;
                    skipCommentOrWhitespace EMPTY_PARAMETER;
                    l = parseExpression(0);
                    skipCommentOrWhitespace EMPTY_PARAMETER;
                    if (!(int)l ACCESS_MEMBER n) r = 4;
                    P = r;
                    y = processNode(0);
                    if (*f == ';') INCREMENT_COUNTER;
                    if (!P) {
                        x = y;
                    }
                    skipWhitespace EMPTY_PARAMETER;
                    if (u) {
                        if (!r && !P) {
                            x = y;
                            f = B;
                            goto j;
                        } else {
                        }
                        CHECK_FUNCTION_END
                            r = (!P && !d) * 4;
                            P = r;
                            y = processNode(0);
                            if (!P) {
                                x = y;
                            }
                        }
                        r = u ? d & ~2 : d | (r & 3);
                        CHECK_FUNCTION_END
                            u = 1;
                            goto u;
                        CHECK_FUNCTION_END
                            y = parseExpression(0);
                            if (!r) {
                                x = y;
                                r |= 1;
                            }
                        CHECK_FUNCTION_END
                            if (!r) r |= 2;
                    } else if (*f) {
                        y = parseExpression(0);
                        if (!r) x = y;
                        skipCommentOrWhitespace EMPTY_PARAMETER;
                    }
                }
                if (!h) break;
            }
            ACCESS_FIELD l = 1;
            ACCESS_FIELD l = 0;
            q = d;
            return x;
        }
    }
    return 0;
}

NodePointer printNode(NodePointer x) {
    printf("%s", copyNode(ACCESS_FIELD x) ACCESS_MEMBER f);
    return createNode(0);
}

int main(EMPTY_PARAMETER) {
    FORMAT_STRING(g, "print");
    NodePointer x = allocateNode(&q);
    ACCESS_FIELD m = 2;
    ACCESS_FIELD r = printNode;
    char u[1 << 16];
    B = f = u;
    while ((C = getchar EMPTY_PARAMETER) > 0) *f++ = C;
    *f = 0;
    f = B;
    processNode(1);
    return 0;
}
```