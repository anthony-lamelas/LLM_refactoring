```c
// Refactored code with clear comments
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

// Define constants for buffer size
#define BUFFER_SIZE (9 << 14)

// Declare global variables
unsigned short *stack_pointer, *stack_limit, *stack_base;
unsigned char *instruction_pointer, buffer[BUFFER_SIZE], *memory = buffer + 256, **arguments;
char *encoded_strings[] = {
    "T:!", "_SPUa_bZ'", "|a_ bmV_b|V|WcReXoT\250UfRaUT\303fR[T\243Uc-TMTD_fR'PpTMP9TM-^|O\\RVU)RNVTObP&VaP5VTN-UQMUTggP\25V^TDl[SOmXSMXbSMXbSIaSMXbSMXbSMXbo2^|TP!|_VbaUoZa!|YpTJpfR~YpTJpbQI|Z_dZbTKbmXSPXbSPXbSPXbUcRWQgRNVTJqP\23VaYP@WTDb5",
    "R\\TXfRLUpPTTXUcTT!bb!|VZ'", "RRTQdTR!bT}b", "T:bb!", " $TLbo_Ro$TNbUoZ_ )ROUa_ZlP\\Z_$TMb|_ cRKVP:Ua_Vl^UlalU",
    "Z", "Waam``!", "cr", "T<!", "T>!", "TB_", "TD_|aTDl[SOVbU'l", " $TOb!|_Vbbao_Tgg*'fRRU_QMUbaaP4U",
    " RMo$Zb_o; U", "2m^|TJ(oQR", "TggYp>YqZRN`USMP4UQaR,W5", "2[SOmTD_Yx^TDl5", "WQX|W|]|kZU",
    "1YTCl^|OdRM7VaP>TX#$TOb!a0PN", "|OdRM", "7VaP>TY#=Y_TJgR\\T\2027TZ#|TRe|=VTRdVcPNTw7TZ#=PN|OdRM7VaP>TClV1",
    "\r0123456789.,!?_#'\"/\\-:()", "jVnVmVSXWbmZU", "|XoQORPSOUcoVr|UT\210gRMUcoPNUSPXboVrRRUTJfRN5U; } UQURMSVUcoU``Wbm",
    "TC_RLU-} UTU)RQTR-1^[l} UTh)RI1U-[_a|[lT\226VfR^[SO_Th)RTR[SOlTD_`[l1", "alZQPUl", "R`TXfRMZUq} TXUcTT!bbZ'8PJZ",
    "|ZU", " $*QKb|TO*g'ciV", "X9", "\0337\33[H\33[K\33[7m \0 \33[;72H\33[0;1m\0\0338",
    "^f", "ROTu7U^coUTReoRI=UTRdZcTxb7", "TN'fRQUQKSMZhPvUTN)ROZaSK`} UR`TLfR[U`SNZbZbT`!b!|Vb0PxZrRLThPoZTNfRJPTUTM)RYZTN)RKZ} ZTAbO\\PPUSKZcT\243b7^",
    "Tggz{ ,", "`|RP% cRKV", "P<V", "6{  *f6{ * f6{  #` 9'*f6{  #a 9'*'f6{  RM$TLb_*)6{  *g*)6{  *h; {  *g; {  RK:_g6{  RN:|_hVl{  RQ:|_|gVcVl{  RM* 9} V*|{  R\\*RY$TNbo&*'laU_'l Ul{ * bb!; {  *b_",
    "; {  Rj.o_Tgg*)RXU_QMRMUa!PUUa_PP*`TR!bb!; {  RU.|_Tgg*)V'RIb; {  `Tgg._Tgg; {  *b; { * c; {  *d; {  *e; {  *e*d c; {",
    "TWgz r6{ TM/6{ TN/6{ TL/{  RM`_QMa; {  #a 9{  #` 9{  0{ {  RI&{  $TOb!a0{  5; {  Yd``Wbm{   b0{  RM#PJV|; {  [c; ",
    "TWgz5Y; { 5^; { W0m{ W0TU75Y; { { 2TJuo[cR[^mTV!UxTYim]aSIUxUv56{ TX_TJto[cR`^mTV!UwTYimUwQI`nUv5ZTXl6{ TX_Yto[cRdTR^mnjlTNiRP|YYxV`P>TYiUwUvXTKcsZTXlTN!m{ V5; { V{ Ys{ TU7{ 3{ Y6",
    "Tggz ", "Rd2 bmX^ao", "fRJ} (|U,fRLU%UqZUP2; { * bb+'8"
};
long temp, stack_size, control_flag;

void execute_encoded_string(int index) {
    char *encoded_string = encoded_strings[index];
    unsigned short current_stack_size = stack_size;
    unsigned long current_temp = temp;
    int control_flag_temp = control_flag;

    // Iterate through the characters in the encoded string
    while (*encoded_string) {
        short operation_value = stack_size;
        short operation_temp = temp;
        int char_value = *++encoded_string - 72;

        // Adjust character value based on its ASCII
        char_value -= (32 > char_value) ? 6 : 79;

        if (char_value < 0) {
            // Recursively call execute_encoded_string with the adjusted char_value
            execute_encoded_string(char_value);
        } else {
            // Process based on char_value
            encoded_string += (char_value < 6);

            if (control_flag_temp) {
                control_flag_temp = char_value - 44 || temp--;
            } else {
                if (char_value > 4 && char_value < 16) {
                    stack_size = temp;
                }
                // Operations on stack and memory
                long *ptr = &temp;
                *ptr = operation_temp;
                *ptr = operation_value;
                *ptr = 1;
                *ptr = current_stack_size;
                *ptr = -1;
                stack_base = memory + temp;
                *ptr = stack_limit - stack_base;
                *ptr = 0;
                *ptr = memory[temp];
                (*ptr)--;
                (*ptr)++;
                *ptr += *ptr -= *ptr = operation_value * operation_temp;
                *ptr = operation_value / operation_temp;
                *ptr = operation_value < operation_temp;
                *ptr &= *ptr |= *ptr = 1 << temp;
                stack_pointer = stack_limit;
                stack_limit = stack_pointer;
                memory[temp] = *ptr;
                instruction_pointer = memory + temp;
                stack_limit = temp + stack_base;
                current_temp = temp;
                current_stack_size = *ptr = stack_limit[temp];
                stack_limit[temp] = *ptr = !temp;

                if (temp) {
                    exit(0);
                }

                *ptr = open(arguments[temp], 0);
                *ptr = creat(arguments[temp], 384);
                close(temp);
                *ptr = read(temp, instruction_pointer, stack_size);
                *ptr = write(temp, instruction_pointer, stack_size);
                *ptr = temp < 0 ? (srand(-temp), 0) : (rand() % temp + 1);
                control_flag_temp = temp--;
                break;
            }
        }
    }
}

int main(int argc, char **argv) {
    unsigned char *instruction_pointer_backup = !arguments ? arguments = argv, "C" : argv[argc];
    long current_stack_size = stack_size;
    long current_temp = temp;

    if (!control_flag) {
        while ((argc = *instruction_pointer_backup)) {
            short operation_value = stack_size;
            short operation_temp = temp;
            int char_value = *++instruction_pointer_backup - 72;

            char_value -= (32 > char_value) ? 6 : 79;

            if (char_value < 0) {
                execute_encoded_string(char_value);
            } else {
                instruction_pointer_backup += (char_value < 6);

                if (control_flag) {
                    control_flag = char_value - 44 || temp--;
                } else {
                    if (char_value > 4 && char_value < 16) {
                        stack_size = temp;
                    }

                    long *ptr = &temp;
                    *ptr = operation_temp;
                    *ptr = operation_value;
                    *ptr = 1;
                    *ptr = current_stack_size;
                    *ptr = -1;
                    stack_base = memory + temp;
                    *ptr = stack_limit - stack_base;
                    *ptr = 0;
                    *ptr = memory[temp];
                    (*ptr)--;
                    (*ptr)++;
                    *ptr += *ptr -= *ptr = operation_value * operation_temp;
                    *ptr = operation_value / operation_temp;
                    *ptr = operation_value < operation_temp;
                    *ptr &= *ptr |= *ptr = 1 << temp;
                    stack_pointer = stack_limit;
                    stack_limit = stack_pointer;
                    memory[temp] = *ptr;
                    instruction_pointer = memory + temp;
                    stack_limit = temp + stack_base;
                    current_temp = temp;
                    current_stack_size = *ptr = stack_limit[temp];
                    stack_limit[temp] = *ptr = !temp;

                    if (temp) {
                        exit(0);
                    }

                    *ptr = open(arguments[temp], 0);
                    *ptr = creat(arguments[temp], 384);
                    close(temp);
                    *ptr = read(temp, instruction_pointer, stack_size);
                    *ptr = write(temp, instruction_pointer, stack_size);
                    *ptr = temp < 0 ? (srand(-temp), 0) : (rand() % temp + 1);
                    control_flag = temp--;
                    break;
                }
            }
        }
    }

    return 0;
}
```