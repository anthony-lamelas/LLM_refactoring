```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <fcntl.h>
#include <locale.h>
#include <string.h>
#include <unistd.h>
#include <curses.h>
#include <wchar.h>
#include <regex.h>

#define BUF 8192
#define MODE 0644

// Global variables
int y, x, z, w;
char *f, *q;
char b[BUF], *g = b, *h, *c, *√≥, *√≤;
long o, √∂, u, v, l, Q, d = -1;
regex_t e;

// Function prototypes
void T(int);
long P(char *s);
char *Z(long m);
int S(int a);
long E(long m);
long D(long m);
void √õ();
void V(long m);
int G(char *s, int a);
long O(long m);
long A(long m, int a, int n);
long _(long m, long n);
long M(long m);
long N(long m);
void C();
void Y();
void üî•();
void H();
void L();
void K();
void J();
void a();
void B();
void √ä();
void √ã();
void √â();
void √à();
void W();
void ”©();
void I();
void √î();
void X();
void √ì();
void √ç();
void Œ∫();
void –§();
void F();
void √ë();
void √Ç();

char –å[] = "hjklbwHJKL|G/nixydPu\\WQ\003";
void (*Œö[])(void) = {
    H, J, K, L, B, W,
    √ä, √â, √à, √ã,
    a, ”©,
    √ë, F,
    I, √ì,
    √î, X, √ç, √õ,
    √Ç, Œ∫, –§, –§,
    üî•
};

// Calculate position offset in buffer
long P(char *s) {
    return s - b - (s < h ? 0 : h - g);
}

// Retrieve pointer to position in buffer
char *Z(long m) {
    return b + m + (b + m < g ? 0 : h - g);
}

// Calculate character width for UTF-8
int S(int a) {
    return 1 + (a > 193) + (a > 223) + (a > 239);
}

// Advance to next character
long E(long m) {
    return m + (m < P(c) ? S(*Z(m)) : 0);
}

// Move back to start of character
long D(long m) {
    while (0 < m && (192 & *Z(--m)) == 128)
        ;
    return m;
}

// Swap buffer pointers and update positions
void √õ() {
    char *p = √≥;
    √≥ = g;
    g = p;
    p = √≤;
    √≤ = h;
    h = p;
    v = √∂;
    √∂ = o;
    o = v;
    v = o + 1;
}

// Move buffer content
void V(long m) {
    char *p = Z(m);
    while (p < g)
        *--h = *--g;
    while (h < p)
        *g++ = *h++;
    √≥ = g;
    √≤ = h;
    √∂ = o;
}

// Get column width of character
int G(char *s, int a) {
    wint_t t;
    mbtowc(&t, s, 4);
    return t == '\t' ? (8 - ((a & 7))) : (a = wcwidth(t)) < 1 ? 1 : a;
}

// Find start of line
long O(long m) {
    while (0 < m && *Z(--m) != '\n')
        ;
    return (m + 1) * (0 < m);
}

// Advance to next column
long A(long m, int a, int n) {
    char *p;
    while (a < n && (p = Z(m)) < c && *p != '\n') {
        a += G(p, a);
        m = E(m);
    }
    return m;
}

// Calculate next position
long _(long m, long n) {
    char *p;
    int a = 0;
    long i = m;
    while (m < n && (p = Z(m = E(m))) < c) {
        a += G(p, a);
        if (COLS <= a) {
            i = m;
            a = 0;
        }
    }
    return i;
}

// Move to next line boundary
long M(long m) {
    long s = O(m);
    long t = _(s, m);
    if (s < t)
        return _(s, t - 1);
    return _(O(s - 1), s - 1);
}

// Advance to next column position
long N(long m) {
    return E(A(m, x, COLS - 1));
}

// Clear current line
void C() {
    printw("%*s", COLS - getcurx(stdscr), "");
}

// Refresh screen display
void Y() {
    char *p;
    int i, j;
    long s, t, n = P(c);
    if (o < u)
        u = _(O(o), o);
    else if (v <= o && o < N(v))
        u = N(u);
    else if (v <= o) {
        v = u;
        for (u = o, i = LINES - 1 - (o == n); 0 < --i && v < u; ) {
            u = M(u);
        }
        if (u < v)
            u = v;
    }
    erase();
    standout();
    printw("%s %ldB", f, o);
    C();
    if (d < 0)
        s = t = d;
    else if (o < d) {
        s = o;
        t = d;
    } else {
        s = d;
        t = o;
    }
    for (i = 1, j = 0, v = u; standend(), i < LINES; ) {
        if (o == v) {
            y = i;
            x = j;
        }
        if (c <= (p = Z(v)))
            break;
        if (s <= v && v < t)
            standout();
        int t = S(*p);
        mvaddnstr(i, j, p, t);
        v += t;
        j += G(p, j);
        if (*p == '\n' || COLS <= j) {
            j = 0;
            i++;
        }
    }
    if (i++ < LINES) {
        standout();
        mvaddstr(i, 0, "^D");
    }
    move(y, x);
    refresh();
}

// Clear screen and reset position
void üî•() {
    clear();
    z = 0;
}

// Move back to character start
void H() {
    o = D(o);
}

// Move to next character
void L() {
    o = E(o);
}

// Move to column start
void K() {
    o = A(M(o), 0, x);
}

// Move to column end
void J() {
    o = A(N(o), 0, x);
}

// Move to line start
void a() {
    o = A(O(o), 0, z - 1);
    z = 0;
}

// Move back a word
void B() {
    while (0 < o && isspace(*Z(o - 1)))
        --o;
    while (0 < o && !isspace(*Z(o - 1)))
        --o;
}

// Move to top of screen
void √ä() {
    o = u;
}

// Move to bottom of screen
void √ã() {
    o = _(O(v - 1), v - 1);
}

// Move to specific line
void √â() {
    int i;
    for (o = v, i = 1; i < y; i++)
        o = N(o);
    o = A(o, 0, x);
    u = o < P(c) ? v : u;
    for (v = o; i < LINES; i++)
        v = N(v);
}

// Scroll up a page
void √à() {
    for (int i = LINES - 1; 0 < i--; )
        o = M(o);
    for (u = o; 1 < y--; )
        u = M(u);
    o = A(o, 0, x);
}

// Move forward a word
void W() {
    long n = P(c);
    while (o < n && !isspace(*Z(o)))
        ++o;
    while (o < n && isspace(*Z(o)))
        ++o;
}

// Repeat last command
void ”©() {
    long n = P(c);
    for (o = n * (!z); o < n && 1 < z; z--) {
        o = A(o, 0, 999);
        o += o < n;
    }
    u = n;
}

// Insert character
void I() {
    int a, t;
    long n = P(c);
    V(o);
    while ((a = getch()) != 3 && a != 27) {
        t = S(a);
        if (a == 8) {
            while (n < P(c) && (192 & *--g) == 128)
                ;
        } else if (g + t < h) {
            do {
                *g++ = a;
                v++;
            } while (0 < --t && (a = getch()));
        }
        o = P(h);
        Y();
    }
    z = 0;
}

// Copy text to buffer
void √î() {
    long i = d;
    if (d < 0) {
        i = o;
        T(14);
    }
    if (i < o) {
        i ^= o;
        o ^= i;
        i ^= o;
    }
    free(q);
    V(o);
    q = strndup(h, Q = i - o);
    d = -1;
}

// Paste text from buffer
void X() {
    √î();
    h += Q;
    o = P(h);
}

// Move to end of line and paste
void √ì() {
    ungetch('l');
    X();
}

// Paste text from buffer
void √ç() {
    if (q) {
        V(o);
        memcpy(g, q, Q);
        g += Q;
        o = P(h);
        v = o + 1;
    }
}

// Save file
void Œ∫() {
    int i;
    V(0);
    write(i = creat(f, MODE), h, c - h);
    close(i);
}

// Exit program
void –§() {
    f = 0;
}

// Search text using regex
void F() {
    regmatch_t p[1];
    V(P(c));
    *g = 0;
    if (o + l < P(c) && !regexec(&e, Z(o + l), 1, p, REG_NOTBOL))
        o += l + p->rm_so;
    else if (!regexec(&e, b, 1, p, 0))
        o = p->rm_so;
    else {
        l = 0;
        return;
    }
    l = p->rm_eo - p->rm_so + w;
}

// Search text prompt
void √ë() {
    echo();
    standout();
    mvaddch(0, 0, '/');
    C();
    mvgetnstr(0, 1, g, h - g);
    regfree(&e);
    if (regcomp(&e, g, REG_EXTENDED | REG_NEWLINE))
        beep();
    else {
        w = g[0] == '$' && !g[1];
        F();
    }
    z = 0;
}

// Toggle mark
void √Ç() {
    d = d < 0 ? o : -1;
}

// Handle command input
void T(int m) {
    int j = z, a;
    for (z = 0; isdigit(a = getch()); )
        z = z * 10 + a - '0';
    z = j && z ? j * z : z ? z : j;
    for (j = 0; –å[j] && a != –å[j]; j++)
        ;
    if (j < m) {
        do (*Œö[j])(); while (1 < z--);
    }
    z = 0;
}

// Main function
int main(int i, char **j) {
    setlocale(LC_ALL, "");
    if (!initscr())
        return 1;
    raw();
    h = c = b + BUF;
    if (0 < (i = open(f = *++j, 0))) {
        g += read(i, b, c - b);
        close(i);
        if (g < b || c <= g)
            return 2;
    }
    v = 1;
    while (f) {
        noecho();
        Y();
        T(99);
    }
    endwin();
    return 0;
}
```