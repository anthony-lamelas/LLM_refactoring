```c
// Refactored code with clear comments
#include <stdio.h>
#include <unistd.h>
#include <math.h>

// Constants for display dimensions and simulation parameters
#define WIDTH 80
#define HEIGHT 24
#define DELTA_TIME 0.01
#define ELASTICITY 0.5
#define U 0.5
#define RPM 1000
#define TILT 5

typedef float scalar;
typedef struct Quaternion {
    scalar a[4];
} Quaternion;

scalar *energy, mass, offset, rotation_angle = 71.0 / 8136.0 * TILT, gravity, h = 1;
int index = 1, j, k, x, y;
struct Particle {
    Quaternion position, velocity;
    scalar mass;
} particles[1 << 20], *particle_ptr;

// Initialize constants and helper variables
Quaternion rotation_speed = {{71.0 * RPM / 13560.0}};
Quaternion identity = {{1.0}};
Quaternion global_rotation, tmp_rotation, rotation_axis = {{30.0}}, rotation_matrix, gravity_vector;
Quaternion temp_quaternion, force, torque, torque_vectors[3] = {0};

// Function prototypes
void initialize_constants(scalar *p);
Quaternion quaternion_add(Quaternion a, Quaternion b);
Quaternion quaternion_multiply(Quaternion a, Quaternion b);
void compute_square_root(scalar x);
Quaternion scale_quaternion(Quaternion a, scalar b);
scalar dot_product(Quaternion a, Quaternion b);
Quaternion normalize_quaternion(Quaternion a);
int main();

// Initialize constants for quaternion calculations
void initialize_constants(scalar *p) {
    for (k = 1; k < 99; h *= rotation_angle / k++) {
        p[k % 2] += h = k % 2 ? -h : h;
    }
}

// Add two quaternions
Quaternion quaternion_add(Quaternion a, Quaternion b) {
    for (k = 4; k--;) {
        a.a[k] += b.a[k];
    }
    return a;
}

// Multiply two quaternions
Quaternion quaternion_multiply(Quaternion a, Quaternion b) {
    Quaternion result = {0};
    for (k = 16; k--;) {
        result.a[k % 4] += b.a[k / 4] * (1 - (5432 >> k & 2)) * a.a[19995 >> (k > 7 ? 15 - k : k) * 2 & 3];
    }
    return result;
}

// Compute square root using Newton's method
void compute_square_root(scalar x) {
    for (h = k = 99; k; h = (x / h + h) / 2) {
        k--;
    }
}

// Scale a quaternion by a scalar
Quaternion scale_quaternion(Quaternion a, scalar b) {
    temp_quaternion.a[3] = b;
    return quaternion_multiply(a, temp_quaternion);
}

// Calculate dot product of two quaternions
scalar dot_product(Quaternion a, Quaternion b) {
    for (h = k = 0; k < 4; k++) {
        h += a.a[k] * b.a[k];
    }
    return h;
}

// Normalize a quaternion
Quaternion normalize_quaternion(Quaternion a) {
    compute_square_root(dot_product(a, a));
    h = 1 / h;
    return scale_quaternion(a, h);
}

int main() {
    char *buffer = B + 6;
    initialize_constants(global_rotation.a + 2);

    for (particle_ptr = particles; fgets(buffer, WIDTH * HEIGHT - 1, stdin); y--) {
        for (x = 0; j = buffer[x++], j && j != 47;) {
            for (rotation_angle = 0; j > 32 && rotation_angle * 113 < 710; h = (x - 0.5 + index * 61e-7) / 2,
                energy = (scalar *)particle_ptr, mass -= offset /= j % 2 ? 2 : 2e3, *energy = y,
                initialize_constants(energy + 1), rotation_speed = quaternion_add(rotation_speed, scale_quaternion(particle_ptr->position, particle_ptr->mass = offset)),
                particle_ptr++, index = 48271 * index % 65535) {
                rotation_angle += offset = 2.0 / x;
            }
        }
    }

    for (; particle_ptr-- > particles;) {
        particle_ptr->position = quaternion_add(particle_ptr->position, scale_quaternion(rotation_speed, 1 / mass));
    }

    for (;;) {
        usleep(1e4 / 1);

        for (index = HEIGHT * WIDTH; index--; buffer[index] = index > HEIGHT * WIDTH - WIDTH ? (x & 16) + 45 : index % WIDTH ? 32 : 10) {
            x = index + offset;
        }

        for (j = 20; j--;) {
            Quaternion total_force = {mass};
            Quaternion total_torque = {0};
            torque_vectors[0] = torque_vectors[1] = torque_vectors[2] = (Quaternion){0};

            for (particle_ptr = particles; particle_ptr->mass; particle_ptr++) {
                for (index = 3, rotation_speed = particle_ptr->position; index--; torque_vectors[index].a[index] += quaternion_multiply(rotation_speed, rotation_speed).a[3] * particle_ptr->mass) {
                    torque_vectors[index] = quaternion_add(torque_vectors[index], scale_quaternion(rotation_speed, rotation_speed.a[index] * particle_ptr->mass));
                }
            }

            for (rotation_angle = index = 0; index < 3; index++) {
                rotation_angle -= dot_product(torque_vectors[index], rotation_matrix.a[index] = quaternion_multiply(torque_vectors[(index + 1) % 3], torque_vectors[(index + 2) % 3]));
            }

            for (; index--; rotation_matrix.a[index].a[3] = 0) {
                rotation_matrix.a[index] = scale_quaternion(rotation_matrix.a[index], 3 / rotation_angle);
            }

            for (particle_ptr = particles; particle_ptr->mass; particle_ptr++) {
                if (energy = particle_ptr->velocity.a, (index = +WIDTH * (y = HEIGHT - 1.5 - *energy) + (x = 0.5 + (energy[1] - offset) * 2 + WIDTH / 2)) > 0 && index < WIDTH * HEIGHT && 0 < x && x < WIDTH) {
                    buffer[index] = energy[2] < rotation_axis.a[2] && buffer[index] - 64 ? 58 : 64;
                }
            }

            rotation_angle = 0;
            energy = total_torque.a;
            for (particle_ptr = particles; particle_ptr->mass; particle_ptr++) {
                Quaternion negative_force = scale_quaternion(global_rotation, -1);
                negative_force.a[3] *= -1;
                offset = *(particle_ptr->velocity = quaternion_add(negative_force = quaternion_multiply(quaternion_multiply(global_rotation, particle_ptr->position), negative_force), rotation_axis)).a;

                if (offset < 0) {
                    for (index = 4; index--;) {
                        energy[index] = dot_product(rotation_matrix.a[index / 1], quaternion_multiply(negative_force, identity));
                    }

                    gravity = (1 + ELASTICITY) * quaternion_add(force, quaternion_multiply(rotation_speed, negative_force)).a[0] / (*quaternion_multiply(total_torque, negative_force).a - 1 / mass);
                    total_torque = quaternion_add(force, quaternion_multiply(rotation_speed, negative_force));
                    *energy = energy[3] = 0;
                    total_force = quaternion_add(total_force, total_torque = quaternion_add(scale_quaternion(identity, gravity / 1 * offset - gravity), scale_quaternion(normalize_quaternion(total_torque), gravity * U)));
                    torque = quaternion_add(torque, quaternion_multiply(negative_force, total_torque));
                    rotation_angle = rotation_angle > offset ? offset : rotation_angle;
                }
            }

            *rotation_axis.a -= rotation_angle;
            rotation_axis = quaternion_add(rotation_axis, scale_quaternion(force = quaternion_add(force, scale_quaternion(total_force, DELTA_TIME / -mass)), DELTA_TIME));

            for (index = 3; index--;) {
                energy[index] = dot_product(rotation_matrix.a[index], torque) * DELTA_TIME;
            }

            global_rotation = normalize_quaternion(quaternion_add(global_rotation, scale_quaternion(quaternion_multiply(rotation_speed = quaternion_add(rotation_speed, torque), global_rotation), 0.5 * DELTA_TIME)));
        }

        offset += (rotation_axis.a[1] - offset) / 50;
        compute_square_root(dot_product(rotation_speed, rotation_speed) * 36476);
        printf("%s\n%*.0f rpm", B, WIDTH - 5, h);
        B[5] = 72;
    }
}
```