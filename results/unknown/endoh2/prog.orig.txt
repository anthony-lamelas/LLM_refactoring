```c
// Refactored code with clear comments
#include <stdio.h>
#include <unistd.h>
#include <math.h>

#define WIDTH 80
#define HEIGHT 24
#define TIME_STEP 0.01
#define ELASTICITY 0.5
#define FRICTION 0.5
#define RPM 1000
#define TILT 5

typedef float scalar;
typedef struct Quaternion {
    scalar elements[4];
} Quaternion;

scalar* energy;
scalar mass, offset, z, tilt_factor = 71.0 / 8136 * TILT, h = 1;
int index = 1, temp_index, a, b;
struct Particle {
    Quaternion position, velocity;
    scalar mass;
} particles[1 << 20], *current_particle;

char* buffer;
char screen_buffer[HEIGHT * WIDTH + 9] = "\x1b[H\x1b[J";

Quaternion identity = {{1}}, angular_velocity = {{71 * RPM / 13560.}}, inertia[4], rotation_axis, angular_momentum, temp_quaternion;
Quaternion origin = {{30}}, gravity, acceleration, torque, force;

// Function Prototypes
void initialize();
Quaternion quaternion_add(Quaternion a, Quaternion b);
Quaternion quaternion_multiply(Quaternion a, Quaternion b);
void calculate_sqrt(scalar x);
Quaternion quaternion_scalar_multiply(Quaternion a, scalar b);
scalar quaternion_dot(Quaternion a, Quaternion b);
Quaternion normalize_quaternion(Quaternion a);
void update_positions();
void update_velocities();
void render();

int main() {
    buffer = screen_buffer + 6;
    initialize();

    for (current_particle = particles; fgets(buffer, WIDTH * HEIGHT - 1, stdin); b--) {
        for (a = 0; buffer[a] && buffer[a] != '/'; a++) {
            for (z = 0; buffer[a] > 32 && z * 113 < 710; h = (a - 0.5 + index * 61e-7) / 2, energy = (scalar*)current_particle, mass -= z /= buffer[a] % 2 ? 2 : 2e3, *energy = b, quaternion_add(angular_momentum, quaternion_scalar_multiply(current_particle->position, current_particle->mass = z)), current_particle++, index = 48271 * index % 65535) {
                z += 2.0 / a;
            }
        }
    }

    for (; current_particle-- > particles;) {
        current_particle->position = quaternion_add(current_particle->position, quaternion_scalar_multiply(angular_momentum, 1 / mass));
    }

    while (1) {
        usleep((int)(1e4 / 1));
        render();
    }

    return 0;
}

void initialize() {
    for (temp_index = 1; temp_index < 99; h *= tilt_factor / temp_index++) {
        buffer[temp_index % 2] += h = temp_index % 2 ? -h : h;
    }
}

Quaternion quaternion_add(Quaternion a, Quaternion b) {
    for (temp_index = 4; temp_index--;) {
        a.elements[temp_index] += b.elements[temp_index];
    }
    return a;
}

Quaternion quaternion_multiply(Quaternion a, Quaternion b) {
    Quaternion q = gravity;
    for (temp_index = 16; temp_index--;) {
        q.elements[temp_index % 4] += b.elements[temp_index / 4] * (1 - (5432 >> temp_index & 2)) * a.elements[19995 >> (temp_index > 7 ? 15 - temp_index : temp_index) * 2 & 3];
    }
    return q;
}

void calculate_sqrt(scalar x) {
    for (h = temp_index = 99; temp_index; h = (x / h + h) / 2) {
        temp_index--;
    }
}

Quaternion quaternion_scalar_multiply(Quaternion a, scalar b) {
    acceleration.elements[3] = b;
    return quaternion_multiply(a, acceleration);
}

scalar quaternion_dot(Quaternion a, Quaternion b) {
    for (h = temp_index = 0; temp_index < 4; temp_index++) {
        h += a.elements[temp_index] * b.elements[temp_index];
    }
    return h;
}

Quaternion normalize_quaternion(Quaternion a) {
    calculate_sqrt(quaternion_dot(a, a));
    h = 1 / h;
    return quaternion_scalar_multiply(a, h);
}

void update_positions() {
    for (current_particle = particles; current_particle->mass; current_particle++) {
        for (temp_index = 3, angular_momentum = current_particle->position; temp_index--; torque[temp_index].elements[temp_index] += quaternion_multiply(angular_momentum, angular_momentum).elements[3] * current_particle->mass) {
            torque[temp_index] = quaternion_add(torque[temp_index], quaternion_scalar_multiply(angular_momentum, angular_momentum.elements[temp_index] * current_particle->mass));
        }
    }
}

void update_velocities() {
    scalar min_z = 0;
    scalar* velocity_elements = acceleration.elements;
    for (current_particle = particles; current_particle->mass; current_particle++) {
        Quaternion r = quaternion_scalar_multiply(rotation_axis, -1);
        r.elements[3] *= -1;
        z = *(current_particle->velocity = quaternion_add(r = quaternion_multiply(quaternion_multiply(angular_momentum, current_particle->position), r), origin)).elements[0];
        if (z < 0) {
            for (temp_index = 4; temp_index--;) {
                velocity_elements[temp_index] = quaternion_dot(inertia[temp_index], quaternion_multiply(rotation_axis, identity));
            }
            h = (1 + ELASTICITY) * quaternion_add(gravity, quaternion_multiply(angular_velocity, rotation_axis)).elements[0] / (quaternion_multiply(acceleration, rotation_axis).elements[0] - 1 / mass);
            gravity = quaternion_add(gravity, quaternion_multiply(angular_velocity, rotation_axis));
            velocity_elements[0] = velocity_elements[3] = 0;
            force = quaternion_add(force, gravity = quaternion_add(gravity, quaternion_scalar_multiply(normalize_quaternion(gravity), h * FRICTION)));
            torque = quaternion_add(torque, quaternion_multiply(rotation_axis, gravity));
            min_z = min_z > z ? z : min_z;
        }
    }
    origin.elements[0] -= min_z;
}

void render() {
    for (index = HEIGHT * WIDTH; index--; buffer[index] = index > HEIGHT * WIDTH - WIDTH ? (a & 16) + 45 : index % WIDTH ? 32 : 10) {
        a = index + offset;
    }

    update_positions();
    update_velocities();

    for (temp_index = 20; temp_index--;) {
        Quaternion angular_force = {{mass}}, temp_v = gravity, temp_torque[3] = {gravity};
        for (current_particle = particles; current_particle->mass; current_particle++) {
            if ((energy = current_particle->velocity.elements, (index = WIDTH * (b = HEIGHT - 1.5 - *energy) + (a = 0.5 + (energy[1] - offset) * 2 + WIDTH / 2)) > 0 && index < WIDTH * HEIGHT && 0 < a && a < WIDTH)) {
                buffer[index] = energy[2] < origin.elements[2] && buffer[index] - 64 ? 58 : 64;
            }
        }
    }

    offset += (origin.elements[1] - offset) / 50;
    calculate_sqrt(quaternion_dot(angular_velocity, angular_velocity) * 36476);
    printf("%s\n%*.0f rpm", screen_buffer, WIDTH - 5, h);
    screen_buffer[5] = 72;
}
```