#include <stdio.h>
#include <unistd.h>

typedef float S;
typedef struct Q {
    S a[4];
} Q;

char *screenBuffer, buffer[H * W + 9] = "\x1b[H\x1b[J";
S *E, M, O, z, Z = 71.0 / 8136 * tilt, g, h = 1;
int i = 1, j, k, a, b;
struct P {
    Q x, v;
    S m;
} L[1 << 20], *p;

void calculate(S *p) {
    for (k = 1; k < 99; h *= Z / k++) {
        p[k % 2] += h = k % 2 ? -h : h;
    }
}

Q Y, w = { { 71 * rpm / 13560.0 } }, I[4], N = { { 1 } }, V, q, X = { { 30 } }, J, G;

Q add(Q a, Q b) {
    for (k = 4; k--; ) {
        a.a[k] += b.a[k];
    }
    return a;
}

Q multiply(Q a, Q b) {
    Q q = G;
    for (k = 16; k--; ) {
        q.a[k % 4] += b.a[k / 4] * (1 - (5432 >> k & 2)) * a.a[19995 >> (k > 7 ? 15 - k : k) * 2 & 3];
    }
    return q;
}

void sqrt_approx(S x) {
    for (h = k = 99; k; h = (x / h + h) / 2) {
        k--;
    }
}

Q scalar_multiply(Q a, S b) {
    J.a[3] = b;
    return multiply(a, J);
}

S dot_product(Q a, Q b) {
    for (h = k = 0; k < 4; k++) {
        h += a.a[k] * b.a[k];
    }
    return h;
}

Q normalize(Q a) {
    sqrt_approx(dot_product(a, a));
    h = 1 / h;
    return scalar_multiply(a, h);
}

int main() {
    screenBuffer = buffer + 6;
    calculate(q.a + 2);

    for (p = L; fgets(screenBuffer, W * H - 1, stdin); b--) {
        for (a = 0; j = screenBuffer[a++], j && j != '/'; ) {
            for (Z = 0; j > 32 && Z * 113 < 710; h = (a - 0.5 + i * 61e-7) / 2, E = (S *)p, M -= z /= j % 2 ? 2 : 2e3, *E = b, calculate(E + 1), Y = add(Y, scalar_multiply(p->x, p->m = z)), p++, i = 48271 * i % 65535) {
                Z += z = 2.0 / a;
            }
        }
    }

    for (; p-- > L; ) {
        p->x = add(p->x, scalar_multiply(Y, 1 / M));
    }

    for (;;) {
        usleep(1e4 / 1);

        for (i = H * W; i--; screenBuffer[i] = i > H * W - W ? (a & 16) + 45 : i % W ? 32 : 10) {
            a = i + O;
        }

        for (j = 20; j--; ) {
            Q F = { { M } }, T = G, v = G, t[3] = { G };

            for (p = L; p->m; p++) {
                for (i = 3, Y = p->x; i--; t[i].a[i] += multiply(Y, Y).a[3] * p->m) {
                    t[i] = add(t[i], scalar_multiply(Y, Y.a[i] * p->m));
                }
            }

            for (Z = i = 0; i < 3; i++) {
                Z -= dot_product(t[i], I[i] = multiply(t[(i + 1) % 3], t[(i + 2) % 3]));
            }

            for (; i--; I[i].a[3] = 0) {
                I[i] = scalar_multiply(I[i], 3 / Z);
            }

            for (p = L; p->m; p++) {
                if (E = p->v.a, (i = +W * (b = H - 1.5 - *E) + (a = .5 + (E[1] - O) * 2 + W / 2)) > 0 && i < W * H && 0 < a && a < W) {
                    screenBuffer[i] = E[2] < X.a[2] && screenBuffer[i] - 64 ? 58 : 64;
                }
            }

            Z = 0;
            E = v.a;

            for (p = L; p->m; p++) {
                Q r = scalar_multiply(q, -1);
                r.a[3] *= -1;
                z = *(p->v = add(r = multiply(multiply(q, p->x), r), X)).a;

                if (z < 0) {
                    for (i = 4; i--; ) {
                        E[i] = dot_product(I[i], multiply(r, N));
                    }

                    g = (1 + e) * *add(V, multiply(w, r)).a / (*multiply(v, r).a - 1 / M);
                    v = add(V, multiply(w, r));
                    *E = E[3] = 0;
                    F = add(F, v = add(scalar_multiply(N, g / 1 * z - g), scalar_multiply(normalize(v), g * u)));
                    T = add(T, multiply(r, v));
                    Z = Z > z ? z : Z;
                }
            }

            *X.a -= Z;
            X = add(X, scalar_multiply(V = add(V, scalar_multiply(F, dt / -M)), dt));

            for (i = 3; i--; ) {
                E[i] = dot_product(I[i], T) * dt;
            }

            q = normalize(add(q, scalar_multiply(multiply(w = add(w, v), q), .5 * dt)));
        }

        O += (X.a[1] - O) / 50;
        sqrt_approx(dot_product(w, w) * 36476);
        printf("%s\n%*.0f rpm", buffer, W - 5, h);
        buffer[5] = 72;
    }
}