```c
// Refactored code with clear comments
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "jpeglib.h"

#ifdef _WIN32
#include <fcntl.h>

// Windows-specific main function wrapping
#define main temp_main_function(); void run_main(); int main() { \
    int i; \
    for (i = 0; i < 2; i++) _setmode(i, _O_BINARY); \
    run_main(); \
} \
void run_main
#endif

// Helper functions and macros for JPEG processing
#define JPEG_FUNC(x) jpeg_##x;
#define COMPONENT_INFO S.comp_info[j].
#define LOOP_UNTIL(a, b) for (a = 0; a < b; a++)
#define CLIP_VALUE(j, v) \
    g = z = (v > 0) * 7; \
    apply_dct_transform(j, 8, I[v + m + s], *2)
#define DECODE_MACRO(o, s) { \
    int d, e, h, p, q, t, u, v, temp[64]; \
    transform_decode_macro = z + 8 * , +1024; \
    temp[ , *8 + z] = f >> 11; \
    f = transform_decode_macro; \
    (o + s * z)[ , ] = (f >>= 18) & -H ? ~(f >> 31 | -H) : f; \
    f = temp[z * 8 + , -(~H << 17); \
}
#define JPEG_CALL(x) JPEG_FUNC(x##_compress(&d)) JPEG_FUNC(x##_decompress(&S))
#define APPLY_TRANSFORM(j, n, v, w) \
    LOOP_UNTIL(j, n) { \
        q = P[a = z * 8 + g] - v * z + g; \
        p = T[i][a]w; \
        t = r * 2 + (q < 0 ? q : -q); \
        p *= t *= t < 0 ? 0 : t; \
        u -= q * t * p; \
        l += p * p; \
    }
#define APPLY_CONDITION(o, n) \
    if (i o 7) \
        LOOP_UNTIL(z, 15 - n) \
            APPLY_TRANSFORM(g, n, P[b = (n & 9) + 8, -T[i][b])
#define TRANSFORM_MACRO(A, B, C) \
    LOOP_UNTIL(z, 8) { \
        d = t A 2]; \
        d += a A 6]; \
        d *= 4433; \
        h = g A 0] << 13; \
        e = h += p A 4] << 13; \
        u = g -= p; \
        u += a = d - a * 15137; \
        g -= a; \
        e += d += t * 6270; \
        h -= d; \
        p = a A 7]; \
        t = b A 5]; \
        p += v A 3]; \
        t += d A 1]; \
        q = (a + d) * 7373; \
        f = (p + t) * 9633; \
        p = p * 16069 - f; \
        f -= t * 3196; \
        t = (b + v) * 20995; \
        a = q + p - a * 2446; \
        p += t - v * 25172; \
        t -= f + b * 16819; \
        q -= f + d * 12299; \
        f = e - q APPLY_CONDITION(0, C) e + q APPLY_CONDITION(7, C) \
        C u - p APPLY_CONDITION(1, C) u + p APPLY_CONDITION(6, C) \
        C g - t APPLY_CONDITION(2, C) g + t APPLY_CONDITION(5, C) \
        h - a APPLY_CONDITION(3, C) h + a APPLY_CONDITION(4, C) 0; \
    }
#define PROCESS_BLOCK_LOOP \
    LOOP_UNTIL(y, h / 8) { \
        JBLOCK *n = *(*S.mem->access_virt_barray)(v = &S, R[j], y, 1, 1); \
        LOOP_UNTIL(x, w / 8) { \
            JCOEF *c = n[x]; \
            UINT16 *V = Q->quantval; \
            m = (y * s + x) * 8 + s + 1;

int main() {
    struct jpeg_compress_struct d;
    struct jpeg_error_mgr e;
    JQUANT_TBL *Q;
    struct jpeg_decompress_struct S;
    void *v, **R;
    int a, b, i, j, k, g, x, y, z, w, h, s, r, K, H = MAXJSAMPLE + 1;
    int m, f, E, c[64];
    JSAMPLE *I, P[64];
    float T[64][64], q = H * 2, p, t, u, l, X, Y;

    d.err = S.err = jpeg_std_error(&e);
    JPEG_CALL(create)
    jpeg_stdio_dest(&d, stdout);
    jpeg_stdio_src(&S, stdin);
    jpeg_read_header(&S, 1);
    R = v = jpeg_read_coefficients(&S);

    LOOP_UNTIL(i, 64) {
        LOOP_UNTIL(k, 64)
            c[k] = k - i ? 0 : q;
        DECODE_MACRO(P, 8)
        LOOP_UNTIL(k, 64)
            T[i][k] = (P[k] - H / 2) / q;
    }

    LOOP_UNTIL(j, S.num_components) {
        if ((Q = COMPONENT_INFO quant_table)) {
            w = COMPONENT_INFO width_in_blocks * 8;
            COMPONENT_INFO quant_table = 0;
            h = COMPONENT_INFO height_in_blocks * 8;
            s = w * 8 + 2;

            if ((I = malloc((h + 2) * s * sizeof(*I)))) {
                LOOP_UNTIL(K, 3) {
                    PROCESS_BLOCK_LOOP
                    LOOP_UNTIL(i, 64 && !K)
                        c[i] *= V[i];
                    DECODE_MACRO(I + m, s)
                }
            }
            LOOP_UNTIL(i, s)
                *I = I[s], I[h * s + s] = I[h * s], I++;
            LOOP_UNTIL(y, h)
                *I = I[1], I[w + 1] = I[w], I += s;
            I -= s * y + s;
            PROCESS_BLOCK_LOOP
            X = Y = 0;
            LOOP_UNTIL(E, 2) {
                for (f = k = 71; (i = k < 8 ? k * 8 - 8 : k % 8 - 7 ? k - 7 : k / 8 + 55);) {
                    r = V[i];
                    if (E)
                        u = (b = c[i]) * q;
                    else {
                        if (f && k - i - 7)
                            DECODE_MACRO(P, 8)
                        u = l = 0;
                        APPLY_CONDITION(&, 7)
                        APPLY_CONDITION(>, 8)
                        CLIP_VALUE(g, -s)
                        CLIP_VALUE(g, s)
                        CLIP_VALUE(z, -1)
                        CLIP_VALUE(z, 1)
                        u /= l;
                        u += b = c[i];
                    }
                    z = u + (u > 0) - 0.5f;
                    g = (b + (b < 0 ? -r : r) / 2) / r * r;
                    a = ((g < 1) - r) / 2 + g;
                    r -= g ? 1 - a : r + a;
                    f |= b ^= c[k = i] = a = z > r ? r : z < a ? a : z;
                    X += a * g;
                    Y += g * g;
                }
                Y > X ? q = Y / X : E++;
            }
        }
    }
    free(I);
}
LOOP_UNTIL(k, NUM_QUANT_TBLS)
    if ((Q = S.quant_tbl_ptrs[k]))
        LOOP_UNTIL(i, 64)
            Q->quantval[i] = 1;
JPEG_CALL(copy_critical_parameters(&S, &d))
jpeg_write_coefficients(&d, v = R)
JPEG_CALL(finish)
JPEG_CALL(destroy)
}
```