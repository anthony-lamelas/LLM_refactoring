```c
// Refactored code with clear comments
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "jpeglib.h"

#ifdef _WIN32
#include <fcntl.h>
#define main M();int main() { int i; for (i = 0; i < 2; i++) _setmode(i, _O_BINARY); return M(); } int M
#endif

// Helper macro for jpeg function calls
#define JPEG_FUNC(name) jpeg_##name;

// Function Prototypes
void perform_idct(j_decompress_ptr cinfo, jpeg_component_info *compptr, JBLOCKROW coef_block, DCTELEM *workspace, int component_index);
void initialize_quantization_tables(j_decompress_ptr cinfo, j_compress_ptr dinfo);
void process_image(j_decompress_ptr cinfo, j_compress_ptr dinfo, jvirt_barray_ptr *coef_arrays, JSAMPLE *sample_range_limit);

// Main function
int main() {
    struct jpeg_decompress_struct cinfo;
    struct jpeg_compress_struct dinfo;
    struct jpeg_error_mgr jerr;
    jvirt_barray_ptr *coef_arrays;
    JSAMPLE *sample_range_limit;
    int i;

    cinfo.err = jpeg_std_error(&jerr);
    dinfo.err = jpeg_std_error(&jerr);

    jpeg_create_decompress(&cinfo);
    jpeg_create_compress(&dinfo);

    jpeg_stdio_src(&cinfo, stdin);
    jpeg_stdio_dest(&dinfo, stdout);

    jpeg_read_header(&cinfo, TRUE);
    coef_arrays = jpeg_read_coefficients(&cinfo);

    sample_range_limit = (JSAMPLE *)malloc((MAXJSAMPLE * 6 + 6) * sizeof(JSAMPLE));
    if (sample_range_limit == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        return 1;
    }

    process_image(&cinfo, &dinfo, coef_arrays, sample_range_limit);

    free(sample_range_limit);

    jpeg_copy_critical_parameters(&cinfo, &dinfo);
    jpeg_write_coefficients(&dinfo, coef_arrays);

    jpeg_finish_decompress(&cinfo);
    jpeg_finish_compress(&dinfo);

    jpeg_destroy_decompress(&cinfo);
    jpeg_destroy_compress(&dinfo);

    return 0;
}

// Perform Inverse Discrete Cosine Transform (IDCT)
void perform_idct(j_decompress_ptr cinfo, jpeg_component_info *compptr, JBLOCKROW coef_block, DCTELEM *workspace, int component_index) {
    // Implementation of the IDCT operation
    JPEG_FUNC(idct_islow(cinfo, compptr, coef_block, workspace, component_index));
}

// Initialize quantization tables
void initialize_quantization_tables(j_decompress_ptr cinfo, j_compress_ptr dinfo) {
    int tbl_index, i;
    for (tbl_index = 0; tbl_index < NUM_QUANT_TBLS; tbl_index++) {
        JQUANT_TBL *quant_tbl = cinfo->quant_tbl_ptrs[tbl_index];
        if (quant_tbl != NULL) {
            for (i = 0; i < DCTSIZE2; i++) {
                quant_tbl->quantval[i] = 1;
            }
        }
    }
}

// Process the image: perform IDCT, process coefficients, and update sample range
void process_image(j_decompress_ptr cinfo, j_compress_ptr dinfo, jvirt_barray_ptr *coef_arrays, JSAMPLE *sample_range_limit) {
    int comp_index, block_x, block_y, i, j;
    JDIMENSION width_in_blocks, height_in_blocks;
    JQUANT_TBL *quant_tbl;
    jvirt_barray_ptr *coef_barray;
    JBLOCKARRAY coef_buffer;
    JBLOCKROW coef_block;
    JSAMPARRAY sample_array;
    JSAMPLE *sample_ptr;

    for (comp_index = 0; comp_index < cinfo->num_components; comp_index++) {
        jpeg_component_info *compptr = &cinfo->comp_info[comp_index];
        width_in_blocks = compptr->width_in_blocks;
        height_in_blocks = compptr->height_in_blocks;
        quant_tbl = compptr->quant_table;
        if (quant_tbl != NULL) {
            // Initialize sample range limit
            for (i = 0; i < MAXJSAMPLE * 3 / 2; i++) {
                sample_range_limit[i + MAXJSAMPLE + 1] = i;
            }
            for (i = 0; i < MAXJSAMPLE; i++) {
                sample_range_limit[MAXJSAMPLE + 1 + i] = i;
                sample_range_limit[MAXJSAMPLE * 3 + 3 + i] = MAXJSAMPLE;
            }

            // Process each block
            for (block_y = 0; block_y < height_in_blocks; block_y++) {
                coef_barray = coef_arrays[comp_index];
                coef_buffer = (*cinfo->mem->access_virt_barray)((j_common_ptr)cinfo, coef_barray, block_y, 1, FALSE);
                for (block_x = 0; block_x < width_in_blocks; block_x++) {
                    coef_block = coef_buffer[block_x];
                    perform_idct(cinfo, compptr, coef_block, NULL, comp_index);
                }
            }
        }
    }
}
```
