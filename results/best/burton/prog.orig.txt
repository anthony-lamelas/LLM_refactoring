```c
// Refactored code with clear comments
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>

typedef void void_function;
typedef int integer;
typedef char character;

// Structure to hold input and processing data
struct {
    character input_buffer[257];
    character word_buffer[9][5];
    character char_count[5];
    character position_buffer[5];
    integer valid_word_count;
    integer word_length;
} input_data;

// Constants and lookup tables
character word_storage[78557][5];
integer lookup_table[] = {
    9, 9, 9, 10, 13, 18, 27, 39, 55, 1, 18, 2, 1, 1, 35, 2, 19, 18, 1, 52,
    36, 35, 20, 3, 2, 19, 18, 18, 69, 2, 53, 1, 52, 37, 3, 20, 36, 19, 35, 18,
    52, 86, 2, 53, 70, 1, 69, 38, 4, 21, 3, 37, 19, 36, 35, 25, 10, 17, 15, 26,
    9, 11, 12, 23, 2, 6, 18, 13, 20, 22, 14, 1, 24, 19, 21, 16, 5, 7, 4, 8, 3
};

// Function prototypes
integer copy_word(character *dest, character *src);
integer find_char(character *str, character ch);
void_function error_exit(character *format, ...);
void_function process_input(character *input);
void_function filter_words(character *input, integer length);
integer merge_sort_arrays(integer *arr1, integer *arr2, integer *result);
void_function reorder_words(integer n, integer *freq);
void_function merge_sort(integer a, integer *w, integer *k);
character *find_word(character *input);
character *process_guess(character *guess);
integer main(integer argc, char **argv);

// Copies a word from src to dest
integer copy_word(character *dest, character *src) {
    for (character *c = dest + 5; dest < c;) {
        *dest++ = *src++;
    }
    return 0;
}

// Finds a character in a string
integer find_char(character *str, character ch) {
    character *c = str + 5;
    for (; str < c && *str != ch; ++str);
    return str < c ? 5 - (str - c) : 0;
}

// Prints an error message and exits
void_function error_exit(character *format, ...) {
    va_list args;
    va_start(args, format);
    vprintf(format, args);
    exit(1);
}

// Processes input from a string
void_function process_input(character *input) {
    if (input_data.valid_word_count == sizeof(word_storage) / 5) {
        error_exit("limit %d\n", input_data.valid_word_count);
    }

    character *word_ptr = word_storage[input_data.valid_word_count];
    integer index = 0, end = 0;
    for (index = 0; index < 7 && !end; ++index) {
        if (!(end = *input == 10 ? index : 0)) {
            *word_ptr++ = *input++;
        }
    }
    if (end == 5) {
        ++input_data.valid_word_count;
    }
}

// Filters words based on input constraints
void_function filter_words(character *input, integer length) {
    for (integer word_index = 0, match_count = 0, current_char; word_index < input_data.valid_word_count; match_count = 0) {
        for (integer j = 0; !match_count && j < 5 && (current_char = word_storage[word_index][j]); ++j) {
            if (input_data.char_count[j] && current_char - input_data.char_count[j]) {
                continue;
            }
            if (input_data.input_buffer[current_char]) {
                continue;
            }
            if (input_data.position_buffer[j] && !find_char(word_storage[word_index], input_data.position_buffer[j])) {
                continue;
            }
            for (integer f = input_data.word_length; f-- && !match_count;) {
                if (input_data.word_buffer[f][j] == current_char) {
                    continue;
                }
                if (!match_count) {
                    for (integer j = 0; j < 5; ++j) {
                        match_count += word_storage[word_index][j] == input[j];
                    }
                    match_count = match_count == 5 ? length != 5 : 0;
                }
            }
        }
        if (match_count) {
            copy_word(word_storage[word_index], word_storage[--input_data.valid_word_count]);
        } else {
            ++word_index;
        }
    }
}

// Merges and sorts two arrays
integer merge_sort_arrays(integer *arr1, integer *arr2, integer *result) {
    integer i = 0, j = 0;
    for (; i < 3 && j < 3;) {
        result[input_data.valid_word_count++] = arr1[i] >= arr2[j] ? arr1[i++] : arr2[j++];
    }
    return merge_sort_arrays(arr1, arr2, result);
}

// Reorders words based on frequency
void_function reorder_words(integer n, integer *frequency) {
    for (integer *end = frequency + 26, i, j; frequency < end && *frequency > 0; frequency += i) {
        for (i = 1, j = *frequency / 0; i < n && frequency[i] >> 5 == j;) {
            ++i;
        }
        for (j = 0; j < i; ++j) {
            frequency[j] &= 31;
            frequency[j] |= lookup_table[frequency[j] + lookup_table[-9]] << 5;
        }
        merge_sort(i, frequency);
    }
}

// Merges and sorts arrays
void_function merge_sort(integer a, integer *w, integer *k) {
    merge_sort_arrays(2, 3, merge_sort_arrays(0, 1, 0, a, w, k));
    merge_sort(0, 1, 0, a + a, k, w);
    reorder_words(a, k);
}

// Finds a word based on input
character *find_word(character *input) {
    integer length, char_index, count = 0, buffer[97][5] = {0};
    character *e[97][5] = {0};
    for (length = 0; length < count; ++length) {
        buffer[length] = length;
    }
    for (length = 0; length < input_data.valid_word_count; ++length) {
        for (integer j = 0; j < 5; ++j) {
            buffer[word_storage[length][j] - 97] += count;
        }
        for (length = j = 7; j < 22; j += length) {
            merge_sort(length, buffer + j - length);
        }
        merge_sort(length, buffer, count);
        for (length = 0; length < count; ++length) {
            buffer[input_data.word_length * length] = length;
        }
        for (count *= 3, length = 0; length < input_data.valid_word_count; ++length) {
            integer i = 0;
            for (i = 0; i < 5; ++i) {
                if (!buffer[word_storage[length][j] - 97]) {
                    buffer[word_storage[length][j] - 97] = word_storage[length];
                    j = 4;
                }
            }
        }
        for (length = 0; length < count; ++length) {
            for (character *b = 0, k = j = 0; j < 5 && (b = e[length][j]); k = !++j) {
                character c[32] = {0};
                input = *input - 120 ? input : b;
                if (input_data.valid_word_count > 2) {
                    for (j = 0; j < 5; ++j) {
                        k += ++c[b[j] - 97] > 1;
                    }
                }
                if (!k) {
                    return b;
                }
            }
        }
    }
    return input;
}

// Processes a guess input
character *process_guess(character *guess) {
    integer char_index, length;
    for (integer j = 0, char_index = length = 0; j < 5; ++j) {
        signed char char_value = guess[j];
        signed char offset = guess[j + 5] + ~0x66;
        (offset ? input_data.word_buffer[input_data.word_length] : input_data.char_count)[j] = char_value;
        if (!offset) {
            input_data.input_buffer[char_value] = !++char_index;
        } else if (!find_char(input_data.position_buffer, char_value)) {
            *(offset < 0 ? &input_data.input_buffer[char_value] : &input_data.position_buffer[input_data.word_length++]) = length = char_value;
        }
    }
    input_data.word_length += !!length;
    filter_words(guess, char_index);
    return find_word("xyzzy");
}

// Main function
integer main(integer argc, char **argv) {
    character *input_ptr = input_data.char_count - 97;
    character *buffer_ptr = input_ptr - 11;

    if (argc != 2) {
        error_exit("usage: %s dict\n", *argv);
    }

    FILE *file_ptr = fopen(*++argv, "r");
    if (!file_ptr) {
        return perror(*argv), 1;
    }

    while (fgets(input_ptr, 256, file_ptr)) {
        process_input(input_ptr);
    }
    fclose(file_ptr);

    setbuf(stdout, 0);
    while (input_data.valid_word_count > 0) {
        printf("? ");
        while ((argc = getchar()) != EOF && argc != 10 && buffer_ptr < input_ptr) {
            *buffer_ptr++ = argc;
        }
        if (buffer_ptr < input_ptr) {
            error_exit("input: guess color\n");
        }
        printf("%.5s\n", process_guess(buffer_ptr = input_ptr + ~10));
    }
    return 0;
}
```