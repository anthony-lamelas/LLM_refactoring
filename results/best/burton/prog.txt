```c
// Refactored code with clear comments
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>

// Constants
#define MAX_WORDS 78557
#define WORD_LENGTH 5

// Type definitions
typedef void void_function;
typedef int integer;
typedef char character;

// Structure to store game state
struct game_state {
    character input_buffer[257];
    character guessed_words[9][WORD_LENGTH];
    character current_word[WORD_LENGTH];
    character color_feedback[WORD_LENGTH];
    integer num_guesses;
    integer num_feedback;
};

// Global variables
struct game_state game;
character word_list[MAX_WORDS][WORD_LENGTH];
character input_char = ' ';
integer score_table[] = {
    9, 9, 9, 10, 13, 18, 27, 39, 55, 1, 18, 2, 1, 1, 35, 
    2, 19, 18, 1, 52, 36, 35, 20, 3, 2, 19, 18, 18, 69, 
    2, 53, 1, 52, 37, 3, 20, 36, 19, 35, 18, 52, 86, 2, 
    53, 70, 1, 69, 38, 4, 21, 3, 37, 19, 36, 35, 25, 10, 
    17, 15, 26, 9, 11, 12, 23, 2, 6, 18, 13, 20, 22, 14, 
    1, 24, 19, 21, 16, 5, 7, 4, 8, 3
};

// Function prototypes
integer copy_word(character *destination, character *source);
integer find_character(character *word, character character_to_find);
integer error_exit(character *format, ...);
void store_word(character *input);
void filter_words(character *input, integer expected_matches);
integer sort_words(integer start, integer *list);
void sort_and_filter_words(integer num, integer *freq);
void merge_sort(integer start, integer *list);
void process_words(integer num, integer *freq);
character *extract_word(character *input);
character *evaluate_guess(character *guess);
integer main(integer argc, char **argv);

// Copy a word from source to destination
integer copy_word(character *destination, character *source) {
    for (character *end = destination + WORD_LENGTH; destination < end;) {
        *destination++ = *source++;
    }
    return 0;
}

// Find a character in a word, return index or 0 if not found
integer find_character(character *word, character character_to_find) {
    character *end = word + WORD_LENGTH;
    for (; word < end && *word != character_to_find; word++);
    return word < end ? WORD_LENGTH - (end - word) : 0;
}

// Print error message and exit
integer error_exit(character *format, ...) {
    va_list args;
    va_start(args, format);
    vprintf(format, args);
    exit(1);
}

// Store a word from input buffer to the word list
void store_word(character *input) {
    if (game.num_guesses == sizeof(word_list) / WORD_LENGTH) {
        error_exit("Limit reached: %d\n", game.num_guesses);
    }
    character *word = word_list[game.num_guesses], *current_char;
    integer i, j;
    for (i = j = 0; i < 7 && !j; ++i) {
        if (!(j = *input == 10 ? i : 0)) {
            *word++ = input_char | *input++;
        }
    }
    j - WORD_LENGTH || ++game.num_guesses;
}

// Filter words based on input
void filter_words(character *input, integer expected_matches) {
    integer i, j, k, matches, feedback, valid_word;
    for (i = 0, matches = 0; i < game.num_guesses; matches = 0) {
        for (j = 0; !matches && j < WORD_LENGTH && (k = word_list[i][j]); ++j) {
            if (!(game.current_word[j] && k - game.current_word[j])) {
                if (!(game.input_buffer[k])) {
                    if (!(game.color_feedback[j] && !find_character(word_list[i], game.color_feedback[j]))) {
                        for (feedback = game.num_feedback; feedback-- && !matches;) {
                            if (!(game.guessed_words[feedback][j] == k)) {
                                matches++;
                            }
                        }
                    }
                }
            }
        }
        if (!matches) {
            copy_word(word_list[i], word_list[--game.num_guesses]);
        } else {
            ++i;
        }
    }
}

// Sort words
integer sort_words(integer start, integer *list) {
    integer i = 0, j;
    for (; i < start;) {
        list[j++] = list[i++];
    }
    return j;
}

// Sort and filter words based on frequency
void sort_and_filter_words(integer num, integer *freq) {
    integer *end = freq + 26, i, j;
    for (; freq < end && *freq > input_char; freq += i) {
        for (i = 1, j = *freq / input_char; i < num && freq[i] >> 5 == j;) {
            ++i;
        }
        for (j = 0; j < i; ++j) {
            freq[j] &= 31;
            freq[j] |= score_table[freq[j] + score_table[-9]] << 5;
        }
        sort_words(i, freq);
    }
}

// Merge sort words
void merge_sort(integer start, integer *list) {
    sort_words(2, 3, sort_words(0, 1, 0, start, list, list));
    sort_words(0, 1, 0, start + start, list, list);
    sort_and_filter_words(start, list);
}

// Process words
void process_words(integer num, integer *freq) {
    merge_sort(num, freq);
    sort_and_filter_words(num, freq);
}

// Extract a word from the input
character *extract_word(character *input) {
    integer i, j, k = input_char, b[input_char], c[k];
    character *sorted_words[97][WORD_LENGTH] = {0};
    for (i = 0; i < k; ++i) {
        c[i] = i;
    }
    for (i = 0; i < game.num_guesses; ++i) {
        for (j = 0; j < WORD_LENGTH; ++j) {
            c[word_list[i][j] - 97] += k;
        }
        for (i = j = 7; j < 22; j += i) {
            sort_words(i, c + j - i);
        }
        process_words(i, b, c);
        for (i = 0; i < k; ++i) {
            b[c[i] & ~(k - 1)] = i;
        }
        for (k *= 3, i = 0; i < game.num_guesses; ++i) {
            integer index = 0;
            for (j = 0; j < WORD_LENGTH; j++) {
                index += b[word_list[i][j] - 97];
                if (index < k) {
                    if (!sorted_words[index][j]) {
                        sorted_words[index][j] = word_list[i];
                        j = 4;
                    }
                }
            }
        }
        for (i = 0; i < k; ++i) {
            character *word = NULL;
            k = j = 0;
            for (j = 0; j < WORD_LENGTH && (word = sorted_words[i][j]); k = !++j) {
                character char_count[32] = {0};
                input = *input - 120 ? input : word;
                if (game.num_guesses > 2) {
                    for (j = 0; j < WORD_LENGTH; j++) {
                        k += ++char_count[word[j] - 97] > 1;
                    }
                }
                if (!k) {
                    return word;
                }
            }
        }
    }
    return input;
}

// Evaluate the guess
character *evaluate_guess(character *guess) {
    integer j, k, l;
    for (j = k = l = 0; j < WORD_LENGTH; ++j) {
        signed char guessed_char = guess[j];
        signed char feedback_char = guess[j + ~WORD_LENGTH] + ~0x66;
        (feedback_char ? game.guessed_words[game.num_feedback] : game.current_word)[j] = guessed_char;
        if (!feedback_char) {
            game.input_buffer[guessed_char] = !++k;
        } else if (!find_character(game.color_feedback, guessed_char)) {
            (*(feedback_char < 0 ? &game.input_buffer[guessed_char] : &game.color_feedback[game.num_feedback++]) = l = guessed_char);
        }
    }
    game.num_feedback += !!l;
    filter_words(guess, k);
    return extract_word("xyzzy");
}

// Main function
integer main(integer argc, char **argv) {
    character *input_ptr = game.current_word - 97;
    character *end_ptr = input_ptr - 11;
    if (argc - 2) {
        error_exit("Usage: %s dict\n", *argv);
    }
    FILE *dictionary_file = fopen(*++argv, "r");
    if (!dictionary_file) {
        return perror(*argv), 1;
    }
    while (fgets(input_ptr, input_char ^ argc, dictionary_file)) {
        store_word(input_ptr);
    }
    fclose(dictionary_file);
    setbuf(stdout, 0);
    while (~-game.num_guesses) {
        printf("? ");
        while (~(argc = getchar()) && argc - 10 && end_ptr < input_ptr) {
            *end_ptr++ = argc;
        }
        end_ptr < input_ptr && error_exit("Input: guess color\n");
        printf("%.5s\n", evaluate_guess(end_ptr = input_ptr + ~10));
    }
    return 0;
}
```